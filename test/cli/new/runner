#!/bin/sh

# This TOP variable hack is taken from try's test suite
JINMORI_TOP="${JINMORI_TOP:-$(git rev-parse --show-toplevel --show-superproject-working-tree 2>/dev/null || echo "${0%/*}")}"
JINMORI="$JINMORI_TOP/build/jinmori.dbg"
TESTS="$JINMORI_TOP/test/cli/new"
PWD="$(pwd)"
export PWD JINMORI_TOP JINMORI TESTS PWD

# Instead of making a tempfile for each test, we reuse the same file and clear it in between
EXPECTED=$(mktemp)
ACTUAL=$(mktemp)
SAVE=""

cleanup() {
	if [ -e "$EXPECTED" ]; then
		rm -f "$EXPECTED"
	fi

	if [ -e "$ACTUAL" ]; then
		rm -f "$ACTUAL"
	fi

	if [ -n "$SAVE" ]; then
		mv "$SAVE/.jinmori" "$HOME"
		echo "Restored original jinmori installation"
		rmdir "$SAVE"
	fi
}

trap 'cleanup' EXIT

if [ -z "$TRY" ]; then
	echo "Please set \$TRY to the path of your try script" >&2
fi

checkexpect() {
	cmd="$1"
	expected_exit_code="$2"

	path_capture_group="\(.*\)"     # capture group 1 - any chars
	action_capture_group="(\(.*\))" # capture group 2 - any chars surrounded by parens
	reformat="(\2)\t\1"             # action followed by path separated with tab
	pat="s/$path_capture_group $action_capture_group/$reformat/p"

	yes no | "$TRY" "$cmd" >"$ACTUAL" 2>&1 # Don't actually commit when prompted
	actual_exit_code="$?"

	if [ "$actual_exit_code" -ne "$expected_exit_code" ]; then
		cat "$ACTUAL" >&2
		return 1
	fi

	if sed -n "/(.*)/{$pat}" <"$ACTUAL" | sort | diff -wB "$EXPECTED" -; then
		return 0
	else
		return 1
	fi
}

get_nth_line() {
	n="$1"
	file="$2"
	awk 'NR==N { printf "%s", $0 }' N="$n" "$file"
}

if [ -d "$HOME/.jinmori" ]; then
	echo "Existing jinmori installation found at $HOME/.jinmori"
	SAVE=$(mktemp -d)
	mv "$HOME/.jinmori" "$SAVE"
	printf "Temporarily moving $HOME/.jinmori to $SAVE. We'll try to restore it at the end, but if something goes wrong, you can find it there\n\n"
fi

errs=0
for test in "$TESTS"/*.test; do
	get_nth_line 1 "$test" >&2
	printf "...\t" >&2

	cmd=$(get_nth_line 2 "$test")
	exit_code=$(get_nth_line 3 "$test")

	tail -n +4 "$test" | envsubst | sort >"$EXPECTED"

	if checkexpect "$cmd" "$exit_code"; then
		echo "Success"
	else
		echo "Fail"
		errs=$((errs + 1))
	fi
done

if [ "$errs" -gt 0 ]; then
	exit 1
fi
